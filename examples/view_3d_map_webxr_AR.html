<!DOCTYPE html>
<html>
    <head>
        <title>Itowns - WebXR Example</title>

        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="css/example.css">
    </head>
   <body>
        <div id="viewerDiv"></div>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
                }
            }
        </script>
        <!-- Import iTowns source code -->
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <!-- <script src="js/GUI/GuiTools.js"></script> -->
        <div id="description">
            <p><b>GNSS master</b></p>
            <ul id="info">
            </ul>
        </div>
        <script type="module">
            import * as THREE from 'three';
            import { XRButton } from 'three/addons/webxr/XRButton.js';
            import { createText } from 'three/addons/webxr/Text2D.js';

            // const data = await fetch('https://192.168.1.34:8081/geopos').then(r => r.json());
            // console.log(data.latitude, data.longitude, data.altitude); 


            // ------ Get geolocalisation from helmet ------
            function getCurrentPosition() {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        reject(new Error("Geolocation is not supported by your browser"));
                    return;
                    }
                    navigator.geolocation.getCurrentPosition(resolve, reject);
                    // getGeoPos();
                });
            }


            const position = await getCurrentPosition();


            // ---------- SETUP THE VR VIEW : ----------
            // let longitude = data.longitude, latitude = data.latitude; //connect to TCP server
            // let longitude = position.longitude, latitude = position.latitude; // get geoloc
            // let longitude = 2.587640, latitude = 48.840638; // mlv
            //var longitude = 2.4223264, latitude = 48.8447549; // smd
            //var longitude = 2.7922434, latitude = 50.4577818; // loos
            var longitude = 3.294129, latitude = 48.483560; // gouaix

            //var longitude = 3.855731 , latitude = 43.959178; // st hippo

             console.log('init view');
            // Define camera initial position
            const placement = {
                coord: new itowns.Coordinates('EPSG:4326', longitude, latitude),
                range: 10,
                tilt: 5,
                heading: 0,
            }

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            const viewerDiv = document.getElementById('viewerDiv');
            
            // Create a GlobeView
            const view = new itowns.GlobeView(viewerDiv, placement, { webXR: { controllers: true, cameraOnGround: true } });
            
            // Instantiate three's XR Button
            const xrButton = XRButton.createButton(view.renderer, {requiredFeatures: ['local']}); //not supported with Immersive web simulator but working on Quest bowser
            viewerDiv.appendChild(xrButton);

            // ---------- DISPLAY ORTHO-IMAGES : ----------
            // Add one imagery layer to the scene. This layer's properties are
            // defined in a json file, but it could be defined as a plain js
            // object. See `Layer` documentation for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then((config) => {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(new itowns.ColorLayer('Ortho', config),
                );
            });

            // ---------- DISPLAY A DIGITAL ELEVATION MODEL : ----------
            // Add two elevation layers, each with a different level of detail.
            // Here again, each layer's properties are defined in a json file.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                view.addLayer(
                    new itowns.ElevationLayer(config.id, config),
                );
            }
            itowns.Fetcher.json('./layers/JSONLayers/IGN_MNT_HIGHRES.json')
                .then(addElevationLayerFromConfig);
            itowns.Fetcher.json('./layers/JSONLayers/WORLD_DTM.json')
                .then(addElevationLayerFromConfig);
                
                
                
            function colorBuildings(properties) {
                if (properties.usage_1 === 'RÃ©sidentiel') {
                    return color.set(0xFDFDFF);
                } else if (properties.usage_1 === 'Annexe') {
                    return color.set(0xC6C5B9);
                } else if (properties.usage_1 === 'Commercial et services') {
                    return color.set(0x62929E);
                } else if (properties.usage_1 === 'Religieux') {
                    return color.set(0x393D3F);
                } else if (properties.usage_1 === 'Sportif') {
                    return color.set(0x546A7B);
                }

                return color.set(0x555555);
            }

            function altitudeBuildings(properties) {
                return properties.altitude_minimale_sol;
            }

            function extrudeBuildings(properties) {
                return properties.hauteur;
            }

            function acceptFeature(properties) {
                return !!properties.hauteur;
            }

            let color = new itowns.THREE.Color();
            let meshes = [];
            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://data.geopf.fr/wfs/ows?',
                version: '2.0.0',
                typeName: 'BDTOPO_V3:batiment',
                crs: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json'
            });

            const wfsBuildingWireframLayer = new itowns.FeatureGeometryLayer('WFS Building Wireframe',{
                batchId: function (property, featureId) { return featureId; },
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: {
                    fill: {
                        color: new THREE.Color(0x000000),
                        base_altitude: altitudeBuildings,
                        extrusion_height: extrudeBuildings,
                    }
                }
            });
            wfsBuildingWireframLayer.wireframe = true;
            view.addLayer(wfsBuildingWireframLayer);

            const wfsBuildingLayer = new itowns.FeatureGeometryLayer('WFS Building',{
                batchId: function (property, featureId) { return featureId; },
                filter: acceptFeature,
                source: wfsBuildingSource,
                zoom: { min: 14 },
                style: {
                    fill: {
                        color: colorBuildings,
                        opacity: 0.2,
                        base_altitude: altitudeBuildings,
                        extrusion_height: extrudeBuildings,
                    }
                }
            });
            view.addLayer(wfsBuildingLayer);

            function displayGNSSmasterTCPserverStatus(){
                const htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = '';
                htmlInfo.innerHTML += `<li><b>TCP server status:</b>${position.longitude} </li>`;
            }

            displayGNSSmasterTCPserverStatus();

            /**
             * Displays the properties of an object in the 'info' div.
             * @param {Object} properties 
             */
            function displayProperties(properties) {
                const htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = '';
                Object.entries(properties).forEach(([key, value]) => {
                    if (value && key[0] !== '_' && key !== 'geometry_name') {
                        htmlInfo.innerHTML += `<li><b>${key}:</b> ${value}</li>`;  
                    }
                });
            }

            /**
             * Optimized picking function.
             */
            function picking(event) {
                if (!view.controls.isPaused) return;

                const htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = '';

                const intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                if (!intersects.length) return;

                const intersect = intersects[0];
                const batchId = intersect.object.geometry.attributes.batchId.array[intersect.face.a];
                const feature = intersect.object.feature;
                const properties = feature.geometries[batchId].properties;

                displayProperties(properties);
            }

            // Add the event listener only once when the layer is ready
            const layer = view.getLayers().find(l => l.id === 'WFS Building');
            if (layer) {
                layer.whenReady.then(() => {
                    // window.addEventListener('mousemove', picking, false);
                });
            }



            function makeButtonMesh( x, y, z, color ) {
                const geometry = new THREE.BoxGeometry( x, y, z );
                const material = new THREE.MeshBasicMaterial( { color: color } );
                const buttonMesh = new THREE.Mesh( geometry, material );
                buttonMesh.castShadow = true;
                buttonMesh.receiveShadow = true;
                return buttonMesh;
		    }

            /* Debug */
            function makeColorCube(){
                const groupSelectColor = new THREE.Group();

                const red = makeButtonMesh(0.1, 0.1, 0.1, 0x008000, 1, false);
                red.position.set(-0.2, 0, 0);
                const green = makeButtonMesh(0.1, 0.1, 0.1, 0xFF0000, 1, false);
                green.position.set(0, 0, 0);
                const blue = makeButtonMesh(0.1, 0.1, 0.1, 0x0000FF, 1, false);
                blue.position.set(0.2, 0, 0);

                groupSelectColor.add(red);
                groupSelectColor.add(green);
                groupSelectColor.add(blue);

                groupSelectColor.position.set(0, 0.2, -0.5);
                groupSelectColor.name = 'selector';
                return groupSelectColor;
            }


            const xr = view.renderer.xr;

            // listen for 'xrSessionStarted' on the view or renderer
            xr.addEventListener('sessionstart', function(event) {
                const vrControls = view.webXR.vrControls;

                // create sun calibration button
                const sunButton = makeButtonMesh(0.2, 0.1, 0.01, 0xffff00);
                const sunButtonText = createText('Sun', 0.06);
                sunButton.name = 'sunButton';
                sunButtonText.name = 'sunButton';
                sunButton.add(sunButtonText);
                sunButtonText.position.set(0, 0, 0.0051);
                
                // create buildins calibration button
                const buildingsButton = makeButtonMesh(0.3, 0.1, 0.01, 0x008000);
                const buildingsButtonText = createText('Buildings', 0.06);
                buildingsButton.name = 'buildingsButton';
                buildingsButtonText.name = 'buildingsButton';
                buildingsButton.add(buildingsButtonText);
                buildingsButtonText.position.set(0, 0, 0.0051);

                const titleText = createText('Calibration mode', 0.06);


                this.getController(0).addEventListener('connected', (event) => {
                    const groupCubes = makeColorCube();
                    view.scene.add(groupCubes);
                    this.getController(0).add(groupCubes);

                    const controllerRight = this.getController(0);
                    // highlightButton
                    let highlightButton = function update(){
                         // select button
                        
                        let line;
                        controllerRight.children.forEach(element => {
                            if (element.isLine){
                                line = element;
                            }
                        });
                        // console.log(line);

                        const raycaster = new THREE.Raycaster();
                        const pos = new THREE.Vector3();
                        const dir = new THREE.Vector3();

                        if (line){
                            line.getWorldPosition(pos);
                            line.getWorldDirection(dir);

                            raycaster.ray.origin = pos;
                            raycaster.ray.direction = dir.multiplyScalar(-1);

                            // calculate objects intersecting the picking ray
                            const intersects = raycaster.intersectObjects(view.scene.children);
                            if (intersects.length > 0 && intersects[0].object.name == 'buildingsButton') {
                                const buttonBuilding = buildingsButton;
                                buttonBuilding.material = new THREE.MeshBasicMaterial({ color: 0x025C02 });
                                view.notifyChange();
                            } else{
                                buildingsButton.material = new THREE.MeshBasicMaterial({ color: 0x008000 });
                                view.notifyChange();
                            }
                        } 
                    }
                    
                    view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, highlightButton);

                });

                this.getController(1).addEventListener('connected', (event) => {
                    sunButton.position.set(-0.15, 0.2, 0);
                    buildingsButton.position.set(0.15, 0.2, 0);
                    titleText.position.set(0, 0.3, 0);    

                    view.scene.add(sunButton);
                    view.scene.add(buildingsButton);
                    this.getController(1).add(sunButton);
                    this.getController(1).add(buildingsButton);
                    this.getController(1).add(titleText);
                });

                // overwrite right button to simulate sun
                vrControls.onLeftButtonPressed = function(evt) {
                    const sunPos = view.simulateSun();
                    const geometrySun = new THREE.SphereGeometry(15, 32, 16);
                    const materialSun = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const sun = new THREE.Mesh(geometrySun, materialSun);
                    sun.position.set(sunPos.x, sunPos.y, sunPos.z);
                    sun.updateMatrixWorld();
                    view.scene.add(sun);

                    const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 5000)]);

                    const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
                    const line = new THREE.Line(geometry, material);

                    line.position.set(view.camera.camera3D.position.x, view.camera.camera3D.position.y, view.camera.camera3D.position.z);
                    line.lookAt(sunPos);
                    line.updateMatrixWorld();

                    view.scene.add(line);
                };

                vrControls.onRightButtonPressed = function(evt) {
                    // select button
                    const controllerRight = this.controllers.filter( (controller) => controller.name == 'right')[0];
                    
                    let line;
                    controllerRight.children.forEach(element => {element.isLine ? line = element : console.warn('No line in controler') });
                    console.log(line);

                    const raycaster = new THREE.Raycaster();
                    const pos = new THREE.Vector3();
                    const dir = new THREE.Vector3();

                    if (line){
                        line.getWorldPosition(pos);
                        line.getWorldDirection(dir);

                        raycaster.ray.origin = pos;
                        raycaster.ray.direction = dir.multiplyScalar(-1);

                        // calculate objects intersecting the picking ray
                        const intersects = raycaster.intersectObjects(view.scene.children);
                        if (intersects.length > 0 && intersects[0].object.name == 'buildingsButton') {
                            const buttonBuilding = intersects[0].object;
                            buttonBuilding.material = new THREE.MeshBasicMaterial({ color: 0x025C02 })
                            view.notifyChange();
                        }
                    }
                }
            });

            const coord = new itowns.Coordinates('EPSG:4978', 4201605.618022248, 189923.89924819994, 4778955.033659566);
            // set ENH orientation, looking at the sky (Z axis), so Y axis look to the north
            // sunButtonText.lookAt(coord.geodesicNormal.clone().add(sunButtonText.position));
            // sunButton.lookAt(coord.geodesicNormal.clone().add(sunButton.position));
            // // mesh.lookAt(placement.coord.geodesicNormal.clone().add(mesh.position));

            // // set Object to the ground
            // var setObjectToGround = function update(/* dt */) {
            //     itowns.DEMUtils.placeObjectOnGround(view.tileLayer, 'EPSG:4978', sunButton); 
            // };

            // 

        </script>
    </body>
</html>
